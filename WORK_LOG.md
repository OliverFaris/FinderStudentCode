Name: Oliver Faris

| Date  |      Time       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                Update |
|:------|:---------------:|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
| Nov 1 |  10:00-10:30am  |                                                                                                                                                                                               Already, I don't know if I am going to code anything for this V1 because I am pretty lost on where to even start since my understanding is we can't use hashmaps and only arrays and lists which don't support keys that aren't ints. Right now I am trying to get a better understanding of the problem set. I do remember from class you were talking to David and I about it and we basically need make a data structure with constant lookup times. |
| Nov 1 |  10:30:11:00am  |                                                                                                                                                                                                                 From class I remember the big 5 (the table in the middle) talking about tries which got me thinking. Tries basically have constant lookup times but I'm not sure how to make tries have a key value relationship since right now I feel like you can only lookup something in a trie and just see if it exists or not. I think I meant TSTs by the way. When I put all the keys in the TST, how will I know what they're values are?? |
| Nov 2 | 10:00pm-11:00pm | I think I might have solution to the problem above. Maybe once you get to the end of a key, you have a string that says the value. I think this has potential to work but honestly I don't know if this takes full advantage of a TST like the dictionary did. I think a TST worked with the dictionary well since after each node, it eliminates a lot of possibilities since the words in a dictionary aren't that far apart in spelling from word to word if that makes sense. But in this case, I feel like after each node, the TST doesn't get rid of a ton of possibilities since our data sets might have very different spellings and stuff. |
| Nov 2 |  11:00-11:30pm  |                                                                                                                                                                                                       Another idea I had was using hashing somehow. The main thing behind my idea is that if we can turn the keys into numbers, then we can just use a simple array... right? I do see some problems with this though. First, the hashes probably won't be evenly spaced out at all and will probably just waste a lot of space in the array since a lot of indecies will have nothing in them. In retrospect this just seems like a really bad idea. |
| Nov 2 |  11:30-11:50pm  |                                                                                                                                                 I got really confused with all this so to zoom out, first I will make the data structure, maybe it will have its own class. Then, in build table, I will insert all the data into the data structure instance. Finally, in query, I will search in the data structre and retrieve the value of the key inputted. How to do all this? My best guess is a TST but I'm really curious for what we will learn in class. Would we basically make a hashmap from scratch or something completely unrelated? |
| Nov 3 |  After lecture  |                                                                                                                                                                                              I learned what the test cases represent and gained a better understanding on how the problem set works. I do wonder why we need two arrays instead of just one though. Because if our key hashes become the index, can't we just put the value in that spot and not have a keys list? Maybe its inefficient when getting the value since you need to hash key again but I'm not sure. If we are doing it the double array way it must be better somehow. |
| Nov 5 |    Classtime    |                                 During this class I made my `HashMap` class and decided to work on that before doing the main `finder` class. I used the slides to see what functions and instance variables I needed. For the hash function, I decided to use the same one from DNA but with a radix of 256 since the keys and values could have many different characters. I then worked on `resize` where I realized I would need to check for collisions just like in `add`. Also I would need a new array double the size and then fill that up with values from the original keys array and then make the keys array point to the larger array. |
| Nov 7 |    Classtime    |                                                                                                                                                 I started work on add which was pretty similar to my resize-except without the resizing. Mr. Blick helped me realize that I can just call `add` in `resize` to make it more abstract. For some reason I origonally thought I couldn't do this and thought that I had to call add on an hashmap when I could just call it inside my class. I had to change some variables and things but I made the switch. I also made a quick draft of `get`, making sure to move right until I found the right key. |
| Nov 7 |   9:00-9:30pm   |                                                                                                                                                                With Mr. Blicks advice about using the split for `finder`, I filled in both functions. This was the first time testing my code since starting so there were some minor bugs but then the first two cases were green. I realized that this must mean my resizing wasn't working properly since the cases that didn't work were the ones bigger than my default table size. The error was that I didn't set `numElements` back to zero before resizing. That took a while to figure out. |
| Nov 8 |   3:00-3:20pm   |              All of my code was working but it seemed pretty slow having the largest test case barely under 2 seconds. I started by fiddling with the load factor which honestly didn't change too much. The real change happened when I looked at the default table size. I realized that everytime I increased the table size, the faster my code would get. This actually makes sense because if the table size was larger, I wouldn't have to resize as much which makes the runtime shorter since resize is an expensive function to do. I do think I shouldn't make the value to large since that would be wasteful for the smaller test cases. |


To add a new row to the table, click into a cell and then hit shift-enter.